package com.sundy.axon.cache;

import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.WeakReference;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.CopyOnWriteArraySet;

public class WeakReferenceCache implements Cache {

	private final ConcurrentMap<Object, Entry> cache = new ConcurrentHashMap<Object, WeakReferenceCache.Entry>();
	private final ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
	private final Set<EntryListener> adapters = new CopyOnWriteArraySet<Cache.EntryListener>();
	
	public <K, V> V get(K key) {
		purgeItems();
		final Reference<Object> entry = cache.get(key);
		final V retrunValue = entry==null ? null:entry.get();
		if(entry)
		return null;
	}

	public <K, V> void put(K key, V value) {
		// TODO Auto-generated method stub

	}

	public <K, V> boolean putIfAbsent(K key, V value) {
		// TODO Auto-generated method stub
		return false;
	}

	public <K> boolean remove(K key) {
		// TODO Auto-generated method stub
		return false;
	}

	public <K> boolean containsKey(K key) {
		// TODO Auto-generated method stub
		return false;
	}

	public void registerCacheEntryListener(EntryListener cacheEntryListener) {
		this.adapters.add(cacheEntryListener);
	}

	public void unregisterCacheEntryListener(EntryListener cacheEntryListener) {
		this.adapters.remove(cacheEntryListener);
	}
	
	private void purgeItems(){
		Entry purgedEntry;
		while((purgedEntry=(Entry) referenceQueue.poll())!=null){
			if(cache.remove(purgedEntry.getKey())!=null){
				for(EntryListener entryListener : adapters){
					entryListener.onEntryExpired(purgedEntry.getKey());
				}
			}
		}
	}
	
	private class Entry extends WeakReference<Object> {
		private final Object key;
		
		public Entry(Object key, Object value){
			super(key, referenceQueue);
			this.key = key;
		}
		
		public Object getKey(){
			return key;
		}
	}

}
