package com.sundy.axon.cache;

import java.lang.ref.ReferenceQueue;
import java.lang.ref.WeakReference;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.CopyOnWriteArraySet;

public class WeakReferenceCache implements Cache {

	private final ConcurrentMap<Object, Entry> cache = new ConcurrentHashMap<Object, WeakReferenceCache.Entry>();
	private final ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
	private final Set<EntryListener> adapters = new CopyOnWriteArraySet<Cache.EntryListener>();
	
	public <K, V> V get(K key) {
		// TODO Auto-generated method stub
		return null;
	}

	public <K, V> void put(K key, V value) {
		// TODO Auto-generated method stub

	}

	public <K, V> boolean putIfAbsent(K key, V value) {
		// TODO Auto-generated method stub
		return false;
	}

	public <K> boolean remove(K key) {
		// TODO Auto-generated method stub
		return false;
	}

	public <K> boolean containsKey(K key) {
		// TODO Auto-generated method stub
		return false;
	}

	public void registerCacheEntryListener(EntryListener cacheEntryListener) {
		// TODO Auto-generated method stub

	}

	public void unregisterCacheEntryListener(EntryListener cacheEntryListener) {
		// TODO Auto-generated method stub

	}
	
	private class Entry extends WeakReference<Object> {
		private final Object key;
		
		public Entry(Object key, Object value){
			super(key, arg1)
		}
	}

}
